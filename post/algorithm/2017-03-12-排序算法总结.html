<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>排序算法总结 - Writing Lite</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="排序算法总结"><meta property="og:description" content="排序算法分为比较排序算法与非比较排序算法，通过决策树可以证明，比较排序算法性能的下界为nlogn。但非比较排序算法就没有此限制，可以达到线性复杂度，但也会有一定的限制。本篇会先介绍常见的几种比较排序算法，然后再介绍几个非比较排序算法。
比较排序算法 插入排序（INSERTION-SORT） 插入排序采用增量方法是一种原址排序，它的工作方式像排序一手扑克牌。我人每次从桌子上拿走一张牌将它插入左手中正确的位置。
伪码 INSERTION-SORT(A) for j=2 to A.length key=A[j] //将A[j]插入到已排序的序列中 i=j-1 while i>0 and A[i]>key A[i+1]=A[i] i=i-1 A[i+j]=key 时间复杂度 插入排序的最坏情况运行时间为$\Theta(n^2)$，最好情况的运行时间为$\theta(n)$
java代码 gist 60af1c98917c6bc6115e639d1d491f9c
归并排序（MERGE-SORT） 归并排序采用分治方法，它需要额外的空间，所以不是原址排序的。归并排序的思想是，将数据分成两个子数组，分别对这两个子数组进行排序，最后再将其合并。
伪码 MERGE-SORT(A,p,r) if p<r q=(p+r)/2//向下取整 MERGE-SORT(A,p,q) MERGE-SORT(A,q+1,r) MERGE(A,p,q,r) MERGE(A,p,q,r) 时间复杂度 归并排序的递归式为： $$ T(n) = \begin{cases} c, & \text{n=1} \
2T(n/2)+cn, & \text{n>1} \
\end{cases} $$ c代表求解规模为1的问题所需的时间以及在分解步骤与合并步骤处理每个数组元素所需的时间。 因此，它的时间复杂度为$\Theta(n\log n)$
java代码 gist 0159937f2bc9a536f3685ebc5bfbbad1
快度排序（QUICKSORT）（非随机） 快速排序也采用分治方法，是原址排序的。在比较排序中（本篇介绍），是最快的排序算法。快速排序的思想是，先找到一个主元，根据该主元将数组划分成两个子数组，左子数组中的数小于等于该主元，右数组的数大于主元，其实相当于每一次划分确定了这次划分该主元的位置。
伪码 QUICKSORT(A,p,r) if p<r q=PARTITION(A,p,r) QUICKSORT(A,p,q-1) QUICKSORT(A,q+1,r) PARTITION(A,p,r) x=A[r] i=p-1 for j=p to r-1 if A[j]<=x i=i+1 exchange A[i] with A[j] exchange A[i+1] wotj A[r] return i+1 时间复杂度 最坏情况下，快速排序的时间复杂度为$\Theta(n^2)$，不过在使用随机数方法，通过指示器向量可以证明，随机版本的快速速排序的期望时间复杂度是$\Theta(nlgn)$ 递归式： $$ T(n)=2T(n/2)+\Theta(n) $$"><meta property="og:type" content="article"><meta property="og:url" content="/post/algorithm/2017-03-12-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-03-12T10:50:00+00:00"><meta property="article:modified_time" content="2017-03-12T10:50:00+00:00"><meta itemprop=name content="排序算法总结"><meta itemprop=description content="排序算法分为比较排序算法与非比较排序算法，通过决策树可以证明，比较排序算法性能的下界为nlogn。但非比较排序算法就没有此限制，可以达到线性复杂度，但也会有一定的限制。本篇会先介绍常见的几种比较排序算法，然后再介绍几个非比较排序算法。
比较排序算法 插入排序（INSERTION-SORT） 插入排序采用增量方法是一种原址排序，它的工作方式像排序一手扑克牌。我人每次从桌子上拿走一张牌将它插入左手中正确的位置。
伪码 INSERTION-SORT(A) for j=2 to A.length key=A[j] //将A[j]插入到已排序的序列中 i=j-1 while i>0 and A[i]>key A[i+1]=A[i] i=i-1 A[i+j]=key 时间复杂度 插入排序的最坏情况运行时间为$\Theta(n^2)$，最好情况的运行时间为$\theta(n)$
java代码 gist 60af1c98917c6bc6115e639d1d491f9c
归并排序（MERGE-SORT） 归并排序采用分治方法，它需要额外的空间，所以不是原址排序的。归并排序的思想是，将数据分成两个子数组，分别对这两个子数组进行排序，最后再将其合并。
伪码 MERGE-SORT(A,p,r) if p<r q=(p+r)/2//向下取整 MERGE-SORT(A,p,q) MERGE-SORT(A,q+1,r) MERGE(A,p,q,r) MERGE(A,p,q,r) 时间复杂度 归并排序的递归式为： $$ T(n) = \begin{cases} c, & \text{n=1} \
2T(n/2)+cn, & \text{n>1} \
\end{cases} $$ c代表求解规模为1的问题所需的时间以及在分解步骤与合并步骤处理每个数组元素所需的时间。 因此，它的时间复杂度为$\Theta(n\log n)$
java代码 gist 0159937f2bc9a536f3685ebc5bfbbad1
快度排序（QUICKSORT）（非随机） 快速排序也采用分治方法，是原址排序的。在比较排序中（本篇介绍），是最快的排序算法。快速排序的思想是，先找到一个主元，根据该主元将数组划分成两个子数组，左子数组中的数小于等于该主元，右数组的数大于主元，其实相当于每一次划分确定了这次划分该主元的位置。
伪码 QUICKSORT(A,p,r) if p<r q=PARTITION(A,p,r) QUICKSORT(A,p,q-1) QUICKSORT(A,q+1,r) PARTITION(A,p,r) x=A[r] i=p-1 for j=p to r-1 if A[j]<=x i=i+1 exchange A[i] with A[j] exchange A[i+1] wotj A[r] return i+1 时间复杂度 最坏情况下，快速排序的时间复杂度为$\Theta(n^2)$，不过在使用随机数方法，通过指示器向量可以证明，随机版本的快速速排序的期望时间复杂度是$\Theta(nlgn)$ 递归式： $$ T(n)=2T(n/2)+\Theta(n) $$"><meta itemprop=datePublished content="2017-03-12T10:50:00+00:00"><meta itemprop=dateModified content="2017-03-12T10:50:00+00:00"><meta itemprop=wordCount content="140"><meta itemprop=keywords content="排序,算法,"><meta name=twitter:card content="summary"><meta name=twitter:title content="排序算法总结"><meta name=twitter:description content="排序算法分为比较排序算法与非比较排序算法，通过决策树可以证明，比较排序算法性能的下界为nlogn。但非比较排序算法就没有此限制，可以达到线性复杂度，但也会有一定的限制。本篇会先介绍常见的几种比较排序算法，然后再介绍几个非比较排序算法。
比较排序算法 插入排序（INSERTION-SORT） 插入排序采用增量方法是一种原址排序，它的工作方式像排序一手扑克牌。我人每次从桌子上拿走一张牌将它插入左手中正确的位置。
伪码 INSERTION-SORT(A) for j=2 to A.length key=A[j] //将A[j]插入到已排序的序列中 i=j-1 while i>0 and A[i]>key A[i+1]=A[i] i=i-1 A[i+j]=key 时间复杂度 插入排序的最坏情况运行时间为$\Theta(n^2)$，最好情况的运行时间为$\theta(n)$
java代码 gist 60af1c98917c6bc6115e639d1d491f9c
归并排序（MERGE-SORT） 归并排序采用分治方法，它需要额外的空间，所以不是原址排序的。归并排序的思想是，将数据分成两个子数组，分别对这两个子数组进行排序，最后再将其合并。
伪码 MERGE-SORT(A,p,r) if p<r q=(p+r)/2//向下取整 MERGE-SORT(A,p,q) MERGE-SORT(A,q+1,r) MERGE(A,p,q,r) MERGE(A,p,q,r) 时间复杂度 归并排序的递归式为： $$ T(n) = \begin{cases} c, & \text{n=1} \
2T(n/2)+cn, & \text{n>1} \
\end{cases} $$ c代表求解规模为1的问题所需的时间以及在分解步骤与合并步骤处理每个数组元素所需的时间。 因此，它的时间复杂度为$\Theta(n\log n)$
java代码 gist 0159937f2bc9a536f3685ebc5bfbbad1
快度排序（QUICKSORT）（非随机） 快速排序也采用分治方法，是原址排序的。在比较排序中（本篇介绍），是最快的排序算法。快速排序的思想是，先找到一个主元，根据该主元将数组划分成两个子数组，左子数组中的数小于等于该主元，右数组的数大于主元，其实相当于每一次划分确定了这次划分该主元的位置。
伪码 QUICKSORT(A,p,r) if p<r q=PARTITION(A,p,r) QUICKSORT(A,p,q-1) QUICKSORT(A,q+1,r) PARTITION(A,p,r) x=A[r] i=p-1 for j=p to r-1 if A[j]<=x i=i+1 exchange A[i] with A[j] exchange A[i+1] wotj A[r] return i+1 时间复杂度 最坏情况下，快速排序的时间复杂度为$\Theta(n^2)$，不过在使用随机数方法，通过指示器向量可以证明，随机版本的快速速排序的期望时间复杂度是$\Theta(nlgn)$ 递归式： $$ T(n)=2T(n/2)+\Theta(n) $$"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Writing Lite" rel=home><div class="logo__item logo__text"><div class=logo__title>Writing Lite</div><div class=logo__tagline>Just writing a lite blog</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>排序算法总结</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>hwyang</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-12T10:50:00Z>2017-03-12</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/algorithm.html rel=category>algorithm</a></span></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#比较排序算法>比较排序算法</a><ul><li><a href=#插入排序insertion-sort>插入排序（INSERTION-SORT）</a></li><li><a href=#归并排序merge-sort>归并排序（MERGE-SORT）</a></li><li><a href=#快度排序quicksort非随机>快度排序（QUICKSORT）（非随机）</a></li></ul></li><li><a href=#非比较排序>非比较排序</a><ul><li><a href=#计数排序>计数排序</a></li><li><a href=#基数排序>基数排序</a></li></ul></li></ul></nav></div></div><div class="content post__content clearfix"><p>排序算法分为比较排序算法与非比较排序算法，通过决策树可以证明，比较排序算法性能的下界为nlogn。但非比较排序算法就没有此限制，可以达到线性复杂度，但也会有一定的限制。本篇会先介绍常见的几种比较排序算法，然后再介绍几个非比较排序算法。</p><h2 id=比较排序算法>比较排序算法</h2><h3 id=插入排序insertion-sort>插入排序（INSERTION-SORT）</h3><p>插入排序采用<strong>增量方法</strong>是一种原址排序，它的工作方式像排序一手扑克牌。我人每次从桌子上拿走一张牌将它插入左手中正确的位置。</p><h4 id=伪码>伪码</h4><pre><code>INSERTION-SORT(A)
    for j=2 to A.length
        key=A[j]
        //将A[j]插入到已排序的序列中
        i=j-1
        while i&gt;0 and A[i]&gt;key
            A[i+1]=A[i]
            i=i-1
        A[i+j]=key
</code></pre><h4 id=时间复杂度>时间复杂度</h4><p>插入排序的最坏情况运行时间为$\Theta(n^2)$，最好情况的运行时间为$\theta(n)$</p><h4 id=java代码>java代码</h4><p><code>gist 60af1c98917c6bc6115e639d1d491f9c</code></p><h3 id=归并排序merge-sort>归并排序（MERGE-SORT）</h3><p>归并排序采用<strong>分治方法</strong>，它需要额外的空间，所以不是原址排序的。归并排序的思想是，将数据分成两个子数组，分别对这两个子数组进行排序，最后再将其合并。</p><h4 id=伪码-1>伪码</h4><pre><code>MERGE-SORT(A,p,r)
    if p&lt;r
        q=(p+r)/2//向下取整
    MERGE-SORT(A,p,q)
    MERGE-SORT(A,q+1,r)
    MERGE(A,p,q,r)
MERGE(A,p,q,r)
</code></pre><h4 id=时间复杂度-1>时间复杂度</h4><p>归并排序的递归式为：
$$
T(n) =
\begin{cases}
c, & \text{n=1} \<br>2T(n/2)+cn, & \text{n>1} \<br>\end{cases}
$$
c代表求解规模为1的问题所需的时间以及在分解步骤与合并步骤处理每个数组元素所需的时间。
因此，它的时间复杂度为$\Theta(n\log n)$</p><h4 id=java代码-1>java代码</h4><p><code>gist 0159937f2bc9a536f3685ebc5bfbbad1</code></p><h3 id=快度排序quicksort非随机>快度排序（QUICKSORT）（非随机）</h3><p>快速排序也采用<strong>分治方法</strong>，是原址排序的。在比较排序中（本篇介绍），是最快的排序算法。快速排序的思想是，先找到一个主元，根据该主元将数组划分成两个子数组，左子数组中的数小于等于该主元，右数组的数大于主元，其实相当于每一次划分确定了这次划分该主元的位置。</p><h4 id=伪码-2>伪码</h4><pre><code>QUICKSORT(A,p,r)
    if p&lt;r
        q=PARTITION(A,p,r)
    QUICKSORT(A,p,q-1)
    QUICKSORT(A,q+1,r)

PARTITION(A,p,r)
    x=A[r]
    i=p-1
    for j=p to r-1
        if A[j]&lt;=x
            i=i+1
            exchange A[i] with A[j]
    exchange A[i+1] wotj A[r]
return i+1
</code></pre><h4 id=时间复杂度-2>时间复杂度</h4><p>最坏情况下，快速排序的时间复杂度为$\Theta(n^2)$，不过在使用随机数方法，通过指示器向量可以证明，随机版本的快速速排序的期望时间复杂度是$\Theta(nlgn)$
递归式：
$$
T(n)=2T(n/2)+\Theta(n)
$$</p><h4 id=java代码-2>java代码</h4><p><code>gist 43a8b4ba34d143e8b2ec83e5ff2c4515</code></p><h2 id=非比较排序>非比较排序</h2><h3 id=计数排序>计数排序</h3><p>计算排序假设，n个输入中每一个元素都是0到k区间内的一个整数，其中k为某个整数。当k等于$\Theta(n)$时，排序的运行时间为$\Theta(n)$。另外计数排序的一个重要性质是它是稳定的：具有相同值元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。计数排序的思想是，对每一个输入元素x，确定小于x的元素个数。利用这一信息，可以直接把x在输出数组中的位置上。</p><h4 id=伪码-3>伪码</h4><pre><code>COUNTING-SORT(A,B,K)
    let C[0...k] be a new array
    for i =0 to k
        C[i]=0
    for j =1 to A.length
        C[A[j]]=C[A[j]]+1
    //C[i]记录值i的次数
    for i =1 to k
        C[i]=C[i]+C[i-1]
    for j = A.length downto 1
        B[C[A[j]]]=A[j]
        C[A[j]]=C[A[j]]-1
</code></pre><h4 id=时间复杂度-3>时间复杂度</h4><p>计数排序的时间复杂度是$\Theta(k+n)$，当k=O(n)时，排序的运行时间为$\Theta(n)$。</p><h4 id=java代码-3>java代码</h4><p><code>gist 854d3575ecadd2079f5415a54863ef02</code></p><h3 id=基数排序>基数排序</h3></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/%E6%8E%92%E5%BA%8F/ rel=tag>排序</a></li><li class=tags__item><a class="tags__link btn" href=/tags/%E7%AE%97%E6%B3%95/ rel=tag>算法</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/machine-learning/2017-02-18-%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B.html rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>混合高斯模型</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/machine-learning/2017-03-12-%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93.html rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>模型简要总结</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Writing Lite.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script><script src=/js/custom.js></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>