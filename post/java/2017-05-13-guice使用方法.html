<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Guice 使用方法 - Writing Lite</title><script>(function(a,b){a[b]=a[b].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Guice 使用方法"><meta property="og:description" content="注入方式 构造方法注入 通过构造方法注入，相对其它方法的好处是，与guice的耦合较低，即使之后不使用guice框架也不用大范围的修改代码。
public class MyImplement { private MyProperty myProperty; @Inject public MyImplement(MyProperty myProperty) { this.myProperty =myProperty; } } 属性注入 属性注入最方便，但不那么符合规范。
public class MyImplement { @Inject private MyProperty myProperty; } 方法注入 如果之前用的是spring通过set方法进行的配置，那么转换到guice就相对简单。
public class MyImplement { private MyProperty myProperty; @Inject public void setMyProperty(MyProperty myProperty) { this.myProperty =myProperty; } } provider注入 如果一个对象有两种或多种不同的生成方式，则可以使用provider方式进行注入。
public static class MyProvider1 implements Provider<MyInterface> { @Inject @Named(&#34;myproperty1&#34;) private MyProperty myProperty; public MyInterface invoke(MyInterface request) { MyImplement myImplement = new MyImplement(); myImplement."><meta property="og:type" content="article"><meta property="og:url" content="/post/java/2017-05-13-guice%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-03-16T09:03:00+00:00"><meta property="article:modified_time" content="2017-03-16T09:03:00+00:00"><meta itemprop=name content="Guice 使用方法"><meta itemprop=description content="注入方式 构造方法注入 通过构造方法注入，相对其它方法的好处是，与guice的耦合较低，即使之后不使用guice框架也不用大范围的修改代码。
public class MyImplement { private MyProperty myProperty; @Inject public MyImplement(MyProperty myProperty) { this.myProperty =myProperty; } } 属性注入 属性注入最方便，但不那么符合规范。
public class MyImplement { @Inject private MyProperty myProperty; } 方法注入 如果之前用的是spring通过set方法进行的配置，那么转换到guice就相对简单。
public class MyImplement { private MyProperty myProperty; @Inject public void setMyProperty(MyProperty myProperty) { this.myProperty =myProperty; } } provider注入 如果一个对象有两种或多种不同的生成方式，则可以使用provider方式进行注入。
public static class MyProvider1 implements Provider<MyInterface> { @Inject @Named(&#34;myproperty1&#34;) private MyProperty myProperty; public MyInterface invoke(MyInterface request) { MyImplement myImplement = new MyImplement(); myImplement."><meta itemprop=datePublished content="2017-03-16T09:03:00+00:00"><meta itemprop=dateModified content="2017-03-16T09:03:00+00:00"><meta itemprop=wordCount content="260"><meta itemprop=keywords content="guice,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Guice 使用方法"><meta name=twitter:description content="注入方式 构造方法注入 通过构造方法注入，相对其它方法的好处是，与guice的耦合较低，即使之后不使用guice框架也不用大范围的修改代码。
public class MyImplement { private MyProperty myProperty; @Inject public MyImplement(MyProperty myProperty) { this.myProperty =myProperty; } } 属性注入 属性注入最方便，但不那么符合规范。
public class MyImplement { @Inject private MyProperty myProperty; } 方法注入 如果之前用的是spring通过set方法进行的配置，那么转换到guice就相对简单。
public class MyImplement { private MyProperty myProperty; @Inject public void setMyProperty(MyProperty myProperty) { this.myProperty =myProperty; } } provider注入 如果一个对象有两种或多种不同的生成方式，则可以使用provider方式进行注入。
public static class MyProvider1 implements Provider<MyInterface> { @Inject @Named(&#34;myproperty1&#34;) private MyProperty myProperty; public MyInterface invoke(MyInterface request) { MyImplement myImplement = new MyImplement(); myImplement."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Writing Lite" rel=home><div class="logo__item logo__text"><div class=logo__title>Writing Lite</div><div class=logo__tagline>Just writing a lite blog</div></div></a></div><div class=divider></div></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Guice 使用方法</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>hwyang</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2017-03-16T09:03:00Z>2017-03-16</time></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#注入方式>注入方式</a><ul><li><a href=#构造方法注入>构造方法注入</a></li><li><a href=#属性注入>属性注入</a></li><li><a href=#方法注入>方法注入</a></li><li><a href=#provider注入>provider注入</a></li><li><a href=#bind同时初始化>bind同时初始化</a></li></ul></li><li><a href=#module配置>Module配置</a><ul><li><a href=#bind-常量>bind 常量</a></li></ul></li><li><a href=#install-私有模块>install 私有模块</a></li><li><a href=#bind细节>bind细节</a></li></ul></nav></div></div><div class="content post__content clearfix"><h2 id=注入方式>注入方式</h2><h3 id=构造方法注入>构造方法注入</h3><p>通过构造方法注入，相对其它方法的好处是，与guice的耦合较低，即使之后不使用guice框架也不用大范围的修改代码。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyImplement</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> MyProperty myProperty<span style=color:#f92672>;</span>
    <span style=color:#a6e22e>@Inject</span>
    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>MyImplement</span><span style=color:#f92672>(</span>MyProperty myProperty<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>myProperty</span> <span style=color:#f92672>=</span>myProperty<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=属性注入>属性注入</h3><p>属性注入最方便，但不那么符合规范。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyImplement</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Inject</span>
    <span style=color:#66d9ef>private</span> MyProperty myProperty<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=方法注入>方法注入</h3><p>如果之前用的是spring通过set方法进行的配置，那么转换到guice就相对简单。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyImplement</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> MyProperty myProperty<span style=color:#f92672>;</span>
    <span style=color:#a6e22e>@Inject</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setMyProperty</span><span style=color:#f92672>(</span>MyProperty myProperty<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>myProperty</span> <span style=color:#f92672>=</span>myProperty<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=provider注入>provider注入</h3><p>如果一个对象有两种或多种不同的生成方式，则可以使用provider方式进行注入。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyProvider1</span> <span style=color:#66d9ef>implements</span> Provider<span style=color:#f92672>&lt;</span>MyInterface<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Inject</span> <span style=color:#a6e22e>@Named</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;myproperty1&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>private</span> MyProperty myProperty<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>public</span> MyInterface <span style=color:#a6e22e>invoke</span><span style=color:#f92672>(</span>MyInterface request<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        MyImplement myImplement <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyImplement<span style=color:#f92672>();</span>
        myImplement<span style=color:#f92672>.</span><span style=color:#a6e22e>setMyProperty</span><span style=color:#f92672>(</span>myProperty<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MyImplement<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyProvider2</span> <span style=color:#66d9ef>implements</span> Provider<span style=color:#f92672>&lt;</span>MyInterface<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Inject</span> <span style=color:#a6e22e>@Named</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;myproperty2&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>private</span> MyProperty myProperty<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>public</span> MyInterface <span style=color:#a6e22e>invoke</span><span style=color:#f92672>(</span>MyInterface request<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        MyImplement myImplement <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MyImplement<span style=color:#f92672>();</span>
        myImplement<span style=color:#f92672>.</span><span style=color:#a6e22e>setMyProperty</span><span style=color:#f92672>(</span>myProperty<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> MyImplement<span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=bind同时初始化>bind同时初始化</h3><p>如果产生一个对象时，要对该对象进行一些初始化，比如读一些文件之类的操作，可以通过在初始化方法上添加<strong>注解</strong>进行实现。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyImplement</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>private</span> MyProperty myProperty<span style=color:#f92672>;</span>
    <span style=color:#a6e22e>@Inject</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setMyProperty</span><span style=color:#f92672>(</span>MyProperty myProperty<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>myProperty</span> <span style=color:#f92672>=</span>myProperty<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#a6e22e>@Inject</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span><span style=color:#f92672>(){</span>
        <span style=color:#75715e>//init ....
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=module配置>Module配置</h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyModule</span> <span style=color:#66d9ef>extends</span> AbstractModule<span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        bind<span style=color:#f92672>(</span>MyInterface<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span>MyImplement<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h3 id=bind-常量>bind 常量</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>bindConstant<span style=color:#f92672>().</span><span style=color:#a6e22e>annotatedWith</span><span style=color:#f92672>(</span>Names<span style=color:#f92672>.</span><span style=color:#a6e22e>named</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;name&#34;</span><span style=color:#f92672>)).</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;value&#34;</span><span style=color:#f92672>);</span>
</code></pre></div><h2 id=install-私有模块>install 私有模块</h2><p>私有化模块不会与其它模块的注入产生冲突。例如系统中需要两个数据库，可以给这两个数据库配置不同的参数，并暴露出接口即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LocalDBModule</span> <span style=color:#66d9ef>extends</span> PrivateModule <span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        install<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> MyBatisModule<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#a6e22e>@Override</span>
            <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initialize</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
                <span style=color:#66d9ef>final</span> Properties myBatisProperties <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Properties<span style=color:#f92672>();</span>
                myBatisProperties<span style=color:#f92672>.</span><span style=color:#a6e22e>setProperty</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;mybatis.environment.id&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>);</span>
                myBatisProperties<span style=color:#f92672>.</span><span style=color:#a6e22e>setProperty</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;JDBC.schema&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;data/ja/ctrip.ibu.ja.db&#34;</span><span style=color:#f92672>);</span>
                myBatisProperties<span style=color:#f92672>.</span><span style=color:#a6e22e>setProperty</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;JDBC.autoCommit&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;false&#34;</span><span style=color:#f92672>);</span>
                install<span style=color:#f92672>(</span>JdbcHelper<span style=color:#f92672>.</span><span style=color:#a6e22e>SQLITE_FILE</span><span style=color:#f92672>);</span>
                Names<span style=color:#f92672>.</span><span style=color:#a6e22e>bindProperties</span><span style=color:#f92672>(</span>binder<span style=color:#f92672>(),</span> myBatisProperties<span style=color:#f92672>);</span>
                bindDataSourceProviderType<span style=color:#f92672>(</span>PooledDataSourceProvider<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
                bindTransactionFactoryType<span style=color:#f92672>(</span>JdbcTransactionFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
                addMapperClass<span style=color:#f92672>(</span>CandidateMapper<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>});</span>
        bind<span style=color:#f92672>(</span>CandidateMapper<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>annotatedWith</span><span style=color:#f92672>(</span>LocalDB<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span>CandidateMapper<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
        <span style=color:#75715e>//暴露接口
</span><span style=color:#75715e></span>        expose<span style=color:#f92672>(</span>CandidateMapper<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>annotatedWith</span><span style=color:#f92672>(</span>LocalDB<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><h2 id=bind细节>bind细节</h2><p>默认情况下，Guice获取一个实例时，每次都会返回一个新的对象。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyModule</span> <span style=color:#66d9ef>extends</span> AbstractModule<span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        bind<span style=color:#f92672>(</span>MyInterface<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span>MyImplement<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>这个行为可以通过scopes进行配置。可以通过asEagerSingleton()，配置单例。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyModule</span> <span style=color:#66d9ef>extends</span> AbstractModule<span style=color:#f92672>{</span>
    <span style=color:#a6e22e>@Override</span>
    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>configure</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            bind<span style=color:#f92672>(</span>MyInterface<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span>MyImplement<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>asEagerSingleton</span><span style=color:#f92672>();</span>
                <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>对于没有在module跟bind过的对象，也可以通过guice获取，同样是动态创建非单例，如想单例 ，也要显示配置。
在链接绑定中，作用域是应用于绑定源上，而不是应用了绑定目标上。假如我们有一个Appleess类实现了Bar和Grill接口，
下面的绑定配置就存在两个实例，一个用于Bar，另一个用于Grill：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>bind<span style=color:#f92672>(</span>Bar<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span>Applebees<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>in</span><span style=color:#f92672>(</span>Singleton<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>  
bind<span style=color:#f92672>(</span>Grill<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>to</span><span style=color:#f92672>(</span>Applebees<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>in</span><span style=color:#f92672>(</span>Singleton<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</code></pre></div><p>这是因为作用域应用于绑定源(Bar,Grill)，而不是绑定目标(Appless)，如果要求只创建一个实例，则可以在Appless类上添加@Singleton注解，或者再添加一个绑定配置：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>bind<span style=color:#f92672>(</span>Applebees<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>).</span><span style=color:#a6e22e>in</span><span style=color:#f92672>(</span>Singleton<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</code></pre></div><table><thead><tr><th>First Header</th><th>PRODUCTION</th><th>DEVELOPMENT</th></tr></thead><tbody><tr><td>.asEagerSingleton()</td><td>eager</td><td>eager</td></tr><tr><td>.in(Singleton.class)</td><td>eager</td><td>lazy</td></tr><tr><td>.in(Scopes.SINGLETON)</td><td>eager</td><td>lazy</td></tr><tr><td>@Singleton</td><td>eager</td><td>lazy</td></tr></tbody></table><p>单例模式在Java应用中很流行，但这样不能提供多个对象特别是在使用了依赖注入之后。虽然单例模式减少了对象的创建、使垃圾回收推后，但单例对象的初始化需要进行同步。单例对象最适用于：</p><ol><li>有状态对象，如果配置对象或者计数器</li><li>要花很大的代价去创建或者查找</li><li>捆绑了资源的对象，例如数据库连接池</li></ol><p>当一个类加上了@Singleton或者@SessionScoped注解时，它必须是线程安全的。而且被注入到这个类中的类也必须是安全的，应该限制需要进行并发控制状态以最大限度地减少可变性。@RequestScoped对象没有必须是线程安全的，所以一个常见的错误是一个@Singleton或@SessionScoped对象依赖了一个@RequestScoped对象。</p><p>默认情况下Guice采用DEVELOPMENT模式。</p><p>TOOL描述的是带有IDE等插件的运行模式；DEVELOPMENT是指在开发阶段只加载自己需要的功能（对于非立即初始化单例对象采用延后加载），这样来降低加载不需要功能的时间；而PRODUCTION模式是指完全加载所有功能（对于单例对象采用立即加载方式），这样可以更早的发现问题，免得等需要某些功能的时候才发现问题（要知道我们某些功能可能需要特定的条件才能触发）。</p><hr><p>参考：</p><ol><li><a href=http://blog.csdn.net/xtayfjpk/article/details/40662917>http://blog.csdn.net/xtayfjpk/article/details/40662917</a></li><li><a href=https://yq.aliyun.com/articles/52611>https://yq.aliyun.com/articles/52611</a></li></ol></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/guice/ rel=tag>guice</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/machine-learning/2017-03-12-%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%AB%98%E6%96%AF%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90.html rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>生成模型与高斯判别分析</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/reading/2017-03-18-%E7%B2%BE%E8%BF%9B.html rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>精进</p></a></div></nav><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script><script>const gitalk=new Gitalk({clientID:'ffbd91469959056415a6',clientSecret:'c7348e2aa3bf5ecd634acef0df3344e3e039eb9c',repo:'writinglite.com',owner:'writinglite',admin:['writinglite'],id:location.pathname,distractionFreeMode:!1});(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('gitalk-container').innerHTML='Gitalk comments not available by default when the website is previewed locally.';return}gitalk.render('gitalk-container')})()</script></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2021 Writing Lite.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script><script src=/js/custom.js></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script></body></html>