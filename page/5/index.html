<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Writing Lite">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Writing Lite">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hwyoung">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Writing Lite</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Writing Lite</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/06/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/2017-07-06-%E4%BF%A1%E6%81%AF%E7%9A%84%E5%BA%A6%E9%87%8F%E7%86%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/06/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/2017-07-06-%E4%BF%A1%E6%81%AF%E7%9A%84%E5%BA%A6%E9%87%8F%E7%86%B5/" class="post-title-link" itemprop="url">信息的度量熵</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-06 23:18:00" itemprop="dateCreated datePublished" datetime="2017-07-06T23:18:00+00:00">2017-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h2><p>一条信息的信息量与它的不确定性成正比关系。比如说，我们要搞清楚一件非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。相反，如果我们对某件事已经有了较多的了解，那么不需要太多的信息就能把它搞清楚。所以从这个角度来看，可以认为，<strong>信息量就等于不确定性的多少</strong>。</p>
<p>它的定义如下：<br>$$<br>H(X)=-\sum_{x\in X}P(x) \log P(x)<br>$$</p>
<h2 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h2><p>如果 H(Y|X=x) 为变数 Y 在 X 取特定值 x 条件下的熵，那么 H(Y|X)就是 H(Y|X=x) 在 X 取遍所有可能 x 后平均的结果：<br>$$<br>\begin{align}<br>H(Y|X) &amp;= \sum_i^n P(x_i)H(Y|X=x_i) \<br>&amp;= \sum_i^n P(x_i) \sum_j^m P(y_j) \log P(y_j|x_i) \<br>&amp;= \sum_i^n \sum_j^m P(x_i,y_j) \log P(y_j|x_i) \<br>&amp;= - \sum_{x\in X,y \in Y}P(x,y) \log P(y|x) \<br>\end{align}<br>$$<br>现在假定我们还知道X的一些情况，包括它和Y一起出现的概率，以及在X取不同值的前提下X的概率分布。定义在X的条件下Y的条件熵为：<br>$$<br>H(Y|X)=-\sum_{x\in X,y \in Y}P(x,y) \log P(y|x)<br>$$<br>H(Y)&gt;=H(Y|X)，也就是说Y的不确定性下降了。</p>
<h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2><p>互信息有时也叫“信息增益”。当获取的信息和要研究的事物“有关系”时，这些信息才能帮助我们消除不确定性。当然“有关系”这种说法太模糊，太不科学，最好能度化的度量“相关性”。香农在信息论中提出了一个“互信息”的概念作为对两个随机事件“相关性”的量化度量。假定有两个随机事件X和Y，它们的互信息定义如下：<br>$$<br>I(X;Y)=\sum_{x \in X,y \in Y}P(x,y) \log \frac{P(x,y)}{P(x)P(y))}<br>$$<br>其实这个互信息就是，随机事件X的不确定性或者说熵H(X)，以及在知道随机事件Y条件下的不确定性或者说H(X|Y)之间的差异，即：<br>$$<br>I(X;Y)=H(X) - H(X|Y)<br>$$<br>也就是说，<strong>所谓的两个事件相关性的度量，就是在了解了其中一个Y的前提下，对消除另一个X不确定性所提供的信息量</strong>。当X和Y完全相关是，它的取值是1；当两者完全无关时，它的取值是0。</p>
<h2 id="相对熵"><a href="#相对熵" class="headerlink" title="相对熵"></a>相对熵</h2><p>相对熵，在有些文献中它也被称为“交叉熵”，在英文中是 Kullback-Leibler Divergence ，是它的两个提出者的名字命令的，简称KL散度。相对熵也用来衡量相关性，但和变量的互信息不同，它用来衡量两个取值为正数的函数的相似性，它的定义如下：<br>$$<br>KL(f(x)||g(x))=\sum_{x \in X}f(x) \log \frac{f(x)}{g(x)}<br>$$<br>相对熵有如下三条结论：</p>
<ol>
<li>对于两个完全相同的函数，它们的相对熵等于零。</li>
<li>相对熵越大，两个函数的差异越大；反之，相对熵越小，两个函数差异越小。</li>
<li>对于概率分布或者概率密度函数，如果取值均大于零，相对熵可以度量两个随机分布的差异性。</li>
</ol>
<p>在自然语言处理中相对熵的应用很多，比如用来衡量两个常用词在不同文本中的概率分布，看它们是否同义；或者根据两篇文章不同词的分布，看看它们的内容是否相近等等。</p>
<p>另外根据相对熵可以推导出交叉熵。</p>
<h2 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h2><p>将相对熵公式进行变形：</p>
<p>$$<br>\begin{align}<br>KL(f(x)||g(x)) &amp;= \sum_{x \in X}f(x) \log \frac{f(x)}{g(x)} \<br>&amp;= \sum_{x \in X}f(x) \log f(x) - \sum_{x \in X}f(x) \log g(x) \<br>&amp;= -H(f(x)) - \sum_{x \in X}f(x) \log g(x)<br>\end{align}<br>$$</p>
<p>其中$H(f(x))$是真实值的信息熵，第二项就是多分类的交叉熵。因此KL散度也被成为相对熵。</p>
<p>$$<br>CE = - \sum_{x \in X}f(x) \log g(x)<br>$$</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个事物内部会存在随机性，也就是不确定性，而从外部消除这个不确定性唯一的办法是引入信息。如果没有信息，任何公式或者数学的游戏都无法排队不确定性，这个朴素的结论非常重要。</p>
<p>信息的作用在于消除不确定性，自然语言处理的大量问题就是找相关的信息。</p>
<hr>
<p>《数学之美》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/07/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2017-07-06-%E4%BC%BC%E7%84%B6%E4%B8%8E%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2017-07-06-%E4%BC%BC%E7%84%B6%E4%B8%8E%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/" class="post-title-link" itemprop="url">似然与极大似然估计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-06 21:30:00" itemprop="dateCreated datePublished" datetime="2017-07-06T21:30:00+00:00">2017-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>本文先会介绍似然的概念，似然与概率的区别，然后介绍参数估计的方法——极大似然估计。</p>
<h2 id="似然"><a href="#似然" class="headerlink" title="似然"></a>似然</h2><p>在统计学中，似然函数（likelihood function，通常简写为likelihood，似然）是一个非常重要的内容，在非正式场合似然和概率（Probability）几乎是一对同义词，但是在统计学中似然和概率却是两个不同的概念。</p>
<p><strong>概率是在特定环境下某件事情发生的可能性</strong>，也就是结果没有产生之前依据环境所对应的参数来预测某件事情发生的可能性，比如抛硬币，抛之前我们不知道最后是哪一面朝上，但是根据硬币的性质我们可以推测任何一面朝上的可能性均为50%，这个概率只有在抛硬币之前才是有意义的，抛完硬币后的结果便是确定的；</p>
<p>而似然刚好相反，是在<strong>确定的结果下去推测产生这个结果的可能环境（参数）</strong>，还是抛硬币的例子，假设我们随机抛掷一枚硬币1,000次，结果500次人头朝上，500次数字朝上（实际情况一般不会这么理想，这里只是举个例子），我们很容易判断这是一枚标准的硬币，两面朝上的概率均为50%，这个过程就是我们根据结果来判断这个事情本身的性质（参数），也就是似然。</p>
<h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><p>似大似然估计解决的问题是，最大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。似大似然估计经常在机器学习方法中作为一种学习策略。</p>
<p>似然函数的最大值意味着什么？让我们回到概率和似然的定义，概率描述的是在一定条件下某个事件发生的可能性，概率越大说明这件事情越可能会发生；而似然描述的是结果已知的情况下，该事件在不同条件下发生的可能性，似然函数的值越大说明该事件在对应的条件下发生的可能性越大。</p>
<p>也就是说<strong>似然函数取得最大值表示相应的参数能够使得统计模型最为合理。</strong></p>
<p>考虑一个抛硬币的例子。假设这个硬币正面跟反面轻重不同。我们把这个硬币抛80次（即，我们获取一个采样$x_1=H,x_2=T,…..x_{80}$并把正面的次数记下来，正面记为H，反面记为T）。并把抛出一个正面的概率记为p，抛出一个反面的概率记为1-p（因此，这里的  p即相当于上边的 $\theta$ ）。<br>假设我们抛出了49个正面，31个反面，即49次H，31次T。假设这个硬币是我们从一个装了三个硬币的盒子里头取出的。这三个硬币抛出正面的概率分别为p=1/3,  p=1/2,p=2/3.这些硬币没有标记，所以我们无法知道哪个是哪个。<br>使用最大似然估计，通过这些试验数据（即采样数据），我们可以计算出哪个硬币的可能性最大。这个似然函数取以下三个值中的一个：<br>$$<br>P(H=49,T=31 | p=1/3) = (1/3)^{49}(1-1/3) ^{31}= 0.000 \<br>P(H=49,T=31 | p=1/2) = (1/2)^{49}(1-1/2)^{31} = 0.012 \<br>P(H=49,T=31 | p=2/3) = (2/3)^{49}(1-2/3)^{31} = 0.054 \<br>$$<br>我们可以看到当p=2/3时，似然函数取得最大值。这就是  p的最大似然估计。</p>
<p>但在机器学习中我们要估计的并不是离散的情况，因此最大似然估计的一般求解过程是：</p>
<ol>
<li>写出似然函数；</li>
<li>对似然函数取对数，并整理，也就对数似然函数；</li>
<li>求导数，解似然方程，也就是取极值；</li>
</ol>
<hr>
<p>参考：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22092462">https://zhuanlan.zhihu.com/p/22092462</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/wiki/似然函数</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1">https://zh.wikipedia.org/wiki/最大似然估计</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/06/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2017-06-04-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2017-06-04-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">统计学习方法概论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-04 20:30:00" itemprop="dateCreated datePublished" datetime="2017-06-04T20:30:00+00:00">2017-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="统计学习的基本概念"><a href="#统计学习的基本概念" class="headerlink" title="统计学习的基本概念"></a>统计学习的基本概念</h2><h3 id="学习的定义"><a href="#学习的定义" class="headerlink" title="学习的定义"></a>学习的定义</h3><p>如果一个系统能够通过执行某个过程改进它的性能，这就是<strong>学习</strong>。统计学习的对象是数据；统计学习关于数据的基本假设是同类数据具有一定的统计规律，这是统计学习的前提。统计学习的上的是对未知数据进行预测和分析；对数据的预测可以使计算机更加智能化；对数据的分析可以让人们获取新的知识，给人们带来新的发现。</p>
<h3 id="监督学习的学习方法"><a href="#监督学习的学习方法" class="headerlink" title="监督学习的学习方法"></a>监督学习的学习方法</h3><p>从给定的、有限的、用于学习的<strong>训练数据</strong>集合出发，假设数据是独立同分布产生的；并且假设学习的模型属于某个函数集合，称为<strong>假设空间</strong>；应用某个<strong>评价准则</strong>，从假设空间中选取一个最优的模型，使它对已知训练数据及未知<strong>测试数据</strong>在给定的评价准则下有最优的预测；最优模型的选取由算法实现。</p>
<h3 id="实现统计学习方法的步骤"><a href="#实现统计学习方法的步骤" class="headerlink" title="实现统计学习方法的步骤"></a>实现统计学习方法的步骤</h3><ol>
<li> 得到一个有限的训练数据集合</li>
<li> 确定包含所有可能模型的假设空间，即学习模型的集合</li>
<li> 确定模型选择的准则，即学习的策略</li>
<li> 实现求解最优模型的算法，取出学习的算法</li>
<li> 通过学习方法选择最做强模型</li>
<li> 利用学习的最优模型对新数据进行预测和分析</li>
</ol>
<h3 id="不同的预测任务名称"><a href="#不同的预测任务名称" class="headerlink" title="不同的预测任务名称"></a>不同的预测任务名称</h3><ul>
<li>输入变量与输出变量均为连续变量的预测问题称为回归问题。</li>
<li>输出变量为有限个离散变量的预测问题称为分类问题。</li>
<li>输入变量与输出变量均为变量序列的预测问题称为标注问题。</li>
</ul>
<h3 id="联合概率分布"><a href="#联合概率分布" class="headerlink" title="联合概率分布"></a>联合概率分布</h3><p>监督学习假设输入与输出的随机变量X和Y遵循联合概率分布P(X,Y)，P(X,Y)表示分布函数，或分布密度函数。训练数据与测试数据被看作是依联合概率分布P(X,Y)独立同分布产生的。</p>
<h3 id="判别模型"><a href="#判别模型" class="headerlink" title="判别模型"></a>判别模型</h3><p>判别模型对P(y|x)或者说对y建模，直接学习得到y。<br>在计算学习算法时，一般使用candidation似然 就是直接用的P(y|x)<br>常见的判别模型有线性回归、对数回归、线性判别分析、支持向量机、boosting、条件随机场、神经网络等。</p>
<h3 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h3><p>生成模型对P(x|y)或者说对x建模（从下面的公式可以看到），通过如下计算得到 y。<br>$$<br>\begin{aligned}<br>\arg\max\limits_{y}p(y\vert x) &amp;= \arg\max\limits_y\frac{p(x,y)}{p(x)} \<br>&amp;= \arg\max\limits_y\frac{p(x\vert y)p(y)}{p(x)} \<br>&amp;= \arg\max\limits_y p(x\vert y)p(y)<br>\end{aligned}<br>$$<br>在给定x进行比较时，P(x)为固定值，所以P(x)可省略。在计算学习算法时，一般使用joint似然，就是用的P(x,y)=P(x|y)*P(y)，其实和P(y|x) 一样的。<br>生成模型表示的是数据生成的方式 ，就是P(x,y) x和y的联合概率。一般来说数据的生成方式是比较复杂的，所以一般都会对数据的生成方式做一定的假设（比如隐马尔科夫模型、朴素贝叶斯模型）。<br>常见的生产模型有隐马尔科夫模型、朴素贝叶斯模型、高斯混合模型、LDA、Restricted Boltzmann Machine等</p>
<h2 id="统计学习的三要素"><a href="#统计学习的三要素" class="headerlink" title="统计学习的三要素"></a>统计学习的三要素</h2><p>统计学习方法包括模型的假设空间、模型选择的准则以及模型的学习算法，称其为统计学习方法的三要素，简称为模型、策略、算法。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>在监督学习过程中，模型就是所要学习的条件概率分布或决策函数。<strong>模型的假设空间</strong>包含所有可能的条件概率分布或决策函数。<br>假设空间用F表示，假设空间可以定义为决策函数的集合<br>$$<br>F={f|Y=f(x)}<br>$$<br>假设空间也可以定义为条件概率的集合<br>$$<br>F={P|P(Y|X)}<br>$$</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>首先引入损失函数与风险函数的概念。损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。</p>
<h4 id="常用的损失函数"><a href="#常用的损失函数" class="headerlink" title="常用的损失函数"></a>常用的损失函数</h4><p> **0-1损失函数 **<br>$$<br>L(Y,f(X))=<br>\begin{cases}<br>1,Y \neq f(X)\<br>0,Y = f(X)\<br>\end{cases}<br>$$</p>
<p> **平方损失函数 **<br>$$<br>L(Y,f(X))=(Y-f(X))^2<br>$$</p>
<p> **绝对损失函数 **<br>$$<br>L(Y,f(X))=|Y-f(X)|<br>$$</p>
<p> **对数损失函数或对数似然损失函数 **<br>$$<br>L(Y,f(X))=-logP(Y|X)<br>$$</p>
<h4 id="风险函数"><a href="#风险函数" class="headerlink" title="风险函数"></a>风险函数</h4><p>损失函数的期望为是<br>$$<br>R_{exp}(f)=E_p[L(Y,f(X)]=\int_{x*y}L(y,f(x))P(x,y)dxdy<br>$$<br>这是理论上模型f(X)关于联合分布P(X,Y)的平均意义下的损失，称为<strong>风险函数</strong>或<strong>期望损失</strong>。</p>
<p>学习的目标就是选择期望风险最小的模型。由于联合分布p(X,Y)是未知的，$R_{exp}f(x)$不能直接计算。实际上，如果知道联合分布P(X,Y)，可以从联合分布直接求出条件概率分布P(X,Y)，也就不需要学习了。正因为不知道联合概率分布，所以才需要学习。</p>
<p>一方面根据期望风险最小学习模型要用到联合分布，另一方面联合分布又是未知的，所以监督学习就成为一个病态问题。</p>
<h4 id="经验风险"><a href="#经验风险" class="headerlink" title="经验风险"></a>经验风险</h4><p>给定一个训练数据集<br>$$<br>T={ (x_1,y_1),(x_2,y_2),\dots,(x_N,y_N) }<br>$$<br>模型f(X)关于训练数据集的平均损失称为<strong>经验风险</strong>，或<strong>经验损失</strong>。记作$R_{emp}$：<br>$$<br>R_{emp}(f)=\frac{1}{N}\sum_{n=1}^nL(y_i,f(x_i))<br>$$</p>
<p>期望风险$R_{exp}f(x)$是模型关于联合分布的期望损失，经验风险$R_{emp}(f)$是模型关于样本集的平均损失。</p>
<p>根据大数定律，当样本容量N趋于无穷时，经验风险$R_{emp}(f)$趋于期望风险$R_{exp}(f)$。所以一个很自然的想法是用经验风险估计期望风险。但是，由于现实中训练样本数目有限，甚至很小，所以用经验风险估计期望风险常常并不理想，要对经验风险进行一定的矫正。这就关系到监督学习的两个基本策略：经验<strong>风险最小化</strong>和<strong>结构风险最小化</strong>。</p>
<h4 id="经验风险最小化"><a href="#经验风险最小化" class="headerlink" title="经验风险最小化"></a>经验风险最小化</h4><p>经验风险最小化的策略认为经验风险最小的模型是最优模型。根据这一策略，按照经验风险最小化求最优模型就是求解最优化问题：<br>$$<br>R_{srm}(f)=\min_{f\in F}\frac{1}{N}\sum_{n=1}^nL(y_i,f(x_i))<br>$$<br>其中F是假设空间。</p>
<p>当样本容量足够大时，经验风险最小化能够保证有很好的学习效果，在现实中被广泛使用。比如，极大似然估计就是经验风险最小化的例子。当模型是条件概念分布，损失函数是对数缺失函数时，经验最小化就等价于极大似然估计。</p>
<p>当然，当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生后面将叙述的<strong>“过拟合”</strong>现象。</p>
<h4 id="结构风险最小化"><a href="#结构风险最小化" class="headerlink" title="结构风险最小化"></a>结构风险最小化</h4><p>结构风险最小化是为了防止过拟合面提出来的策略。结构风险最小化等价于<strong>正则化</strong>。结构风险在经验风险上加上表示模型复杂度的与此正则化项或罚项。结构风险的定义是：<br>$$<br>R_{srm}(f)=\frac{1}{N}\sum_{n=1}^nL(y_i,f(x_i))+\lambda J(f)<br>$$<br>其中J(f)为模型的复杂度，是定义在假设空间F的泛函。模型f越复杂，复杂度J(f)就越大；反之，模型越简单，复杂度J(f)就越小。$\lambda \ge 0$是系数，用以权衡经验风险和模型复杂度。</p>
<p>结构风险最小化的策略认为结构风险最小的模型是最优模型。所以求解最优模型就是求解最优化问题：<br>$$<br>\min_{f\in \digamma}\frac{1}{N}\sum_{n=1}^nL(y_i,f(x_i))+\lambda J(f)<br>$$</p>
<p>贝叶斯估计中的最大后验概率估计就是结构风险最小化的一个例子。当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模，最后考虑用什么样的计算方法来求解最优模型。这时统计学习问题归结为最优化问题，统计学习的算法成国求解最优化问题的算法。</p>
<h2 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h2><h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>统计学习的目的是使学到的模型不仅对已知数据而且对未知数据都能有很好的预测能力。不同的学习方法会给出不同的模型。当损失函数给定时，基于缺失函数的模型的<strong>训练误差</strong>和模型的<strong>测试误差</strong>就自然成为学习方法评估的标准。注意，统计学习方法具体采用的损失函数未必是评估时使用的损失函数。</p>
<p>假设学习到的模型是$Y=\hat f(X)$<br><strong>训练误差</strong>是模型$Y=f^{\wedge}(X)$关于训练数据集的平均损失：<br>$$<br>R <em>{emp}(\hat f)=\frac{1}{N}\sum</em>{i=1}^NL(y_i,\hat f(x_i)<br>$$<br>其中N是训练样本容量。<br><strong>测试误差</strong>是模型$Y=\hat f(X)$关于测试数据集的平均损失：<br>$$<br>e_{test}=\frac{1}{N^{‘}}\sum_{i=1}^{N^{‘}}L(y_i,\hat f(x_i)<br>$$<br>其中$N^{‘}$是测试样本容量。</p>
<p>训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。测试误差反映了学习方法对于未知的测试数据集的预测能力，是学习中的重要概念。显然，给定两种学习方法，测试误差小的方法具有更好的预测能力，是更有效的方法。通常学习方法对未知数据折预测能力称为泛化能力。</p>
<hr>
<p>《统计学习方法》李航</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/05/21/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/2017-05-21-Stanford%20CoreNLP%20%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/21/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/2017-05-21-Stanford%20CoreNLP%20%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Stanford CoreNLP 使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-21 13:18:00" itemprop="dateCreated datePublished" datetime="2017-05-21T13:18:00+00:00">2017-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>斯坦福CoreNLP提供了一套自然语言分析工具。斯坦福CoreNLP集成了许多斯坦福的NLP工具，包括词性（POS），命名实体识别（NER）， 语法解析，指代消解，情感分析，自举模式学习和开放信息提取工具。</p>
<p>如果有如下需求，要以选择Stanford CoreNLP：</p>
<ul>
<li>具有良好语法分析工具的集成工具包</li>
<li>快速，可靠地分析任意文本</li>
<li>整体最高品质的文字分析</li>
<li>支持一些主要（人类）语言</li>
<li>可用于大多数主要现代编程语言的接口</li>
<li>能够作为简单的Web服务运行</li>
</ul>
<p>Github地址：<a target="_blank" rel="noopener" href="https://github.com/stanfordnlp/CoreNLP">Stanford CoreNLP GitHub site.</a></p>
<h2 id="使用前准备"><a href="#使用前准备" class="headerlink" title="使用前准备"></a>使用前准备</h2><p>Stanford CoreNLP是基于JAVA的，最新版本需要JDK1.8。JAR包可以通用官网，或者MAVEN下载到。如果使用MAVEN的话，可以使用如下配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>edu.stanford.nlp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>stanford-corenlp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>edu.stanford.nlp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>stanford-corenlp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>models<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你想从阿拉伯语，中文，德语或西班牙语中获得Maven的语言模型，请将其添加到您的pom.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>edu.stanford.nlp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>stanford-corenlp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>models-chinese<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将“models-chinese”替换为“models-english”，“models-chinese-kbp”，“models-arabic”，“models-french”，“models-german”或“models-spanish”为其他语言！</p>
<p>由于Stanford CoreNLP的模型文件太大（中文的模型就几百M），建议到官网下载。如果使用MAVEN的话，最好使用阿里的MAVEN仓库，这样速度更快些。</p>
<h2 id="通过命令行使用"><a href="#通过命令行使用" class="headerlink" title="通过命令行使用"></a>通过命令行使用</h2><h3 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp &quot;*&quot; -Xmx2g edu.stanford.nlp.pipeline.StanfordCoreNLP -annotators tokenize,ssplit,pos,lemma,ner,parse,dcoref -file input.txt</span><br></pre></td></tr></table></figure>
<p><code>-cp &quot;*&quot;</code>是加载当前路径下的所有文件（主要是JAR包）</p>
<p>该<code>-props</code>参数是可选的。默认情况下，Stanford CoreNLP将在您的类路径中搜索StanfordCoreNLP.properties，并使用分发中包含的默认值。</p>
<p>该<code>-annotators</code>参数实际上是可选的。如果你离开它，代码使用一个内建的属性文件，它可以使用以下注释器：标记化和句子分割，POS标记，缩小，NER，解析和关联解析（也就是我们在这些例子中使用的）。</p>
<p>如果要使用其它语言的话，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -mx3g -cp &quot;*&quot; edu.stanford.nlp.pipeline.StanfordCoreNLP -props StanfordCoreNLP-chinese.properties -file chinese.txt -outputFormat text</span><br></pre></td></tr></table></figure>
<hr>
<p>参考：<br><a target="_blank" rel="noopener" href="https://stanfordnlp.github.io/CoreNLP/index.html">https://stanfordnlp.github.io/CoreNLP/index.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/05/16/%E7%AE%97%E6%B3%95/2017-05-16-%E5%85%A8%E5%9F%9F%E5%93%88%E5%B8%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/16/%E7%AE%97%E6%B3%95/2017-05-16-%E5%85%A8%E5%9F%9F%E5%93%88%E5%B8%8C/" class="post-title-link" itemprop="url">全域哈希</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-16 20:18:00" itemprop="dateCreated datePublished" datetime="2017-05-16T20:18:00+00:00">2017-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>全域哈希的讲解有些不同，它是先给出一个奇怪的定义，然后推论出一些较好的性质。最后介绍构造方法，并证明符合定义。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设H为一组有限散列函数，它将给定的关键字全域 U映射到{1,2,…m-1}中。这样的一组函数称为全域的，如果对每对不同的关键字$x,y \in U$，满足h(x)=h(y)的散列函数的个数至多为|H|/m。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>推论1 当关键字x!=y时，两者发生冲突的概率小于等于1/m。</p>
<p>推论2 随机选择一个函数，将n个关键字放进T表的m个槽中，对于给定的关键字x，它发生冲突的期望次数小于n/m（也就是装载因子）。<br>$$<br>E[#与x碰撞]&lt;n/m<br>$$<br>证明：<br>设$C_{x}$表示哈希表T里与x发生碰撞的次数<br>$$<br>C_{xy}=<br>\begin{cases}<br>1 \ if \ h(x) = h(y)\<br>0 \  otherwise\<br>\end{cases}<br>$$<br>根据全域函数的定义可知<br>$$<br>E[C_{xy}]=1/m<br>$$<br>因此<br>$$<br>C_x = \sum_{y\in T-{x}}C_{xy}<br>$$<br>$$<br>\begin{align}<br>E[C_x] &amp;= E[\sum_{y\in T-{x}}C_{xy}] \<br>&amp;=\sum_{y\in T-{x}}E\left[C_{xy} \right] \<br>&amp;=\sum_{y\in T-{x}} 1/m \<br>&amp;= \frac{n-1}{m}<br>\end{align}<br>$$</p>
<h2 id="全域哈希构造方法"><a href="#全域哈希构造方法" class="headerlink" title="全域哈希构造方法"></a>全域哈希构造方法</h2><p>假设m是一个质数，将关键字k转换成r+1位的m进制数，$k=&lt;k_0,k_1,\dots,k_r&gt;,0&lt;=k_r&lt;=m-1$<br>设随机数$a=&lt;a_0,a_1,\dots,a_r&gt;$同样为成r+1位的m进制数，defin 哈希函数为<br>$$<br>h_a(x)=(\sum_{i=0}^ra_ik_i) \mod m<br>$$<br>哈希函数集H的大小为$m^{r+1}$</p>
<p>设x!=y，也就是说，$x_0,\dots x_r$中必然至少有一位是不同的，这里假设不同的那一位就是第0位，即$x_0!=y_0$<br>$$<br>x=&lt;x_0,x_1,\dots,x_r&gt; \<br>y=&lt;y_0,y_1,\dots,y_r&gt;<br>$$<br>如果x与y发生碰撞，也就是说h(x)=h(y)<br>$$<br>(\sum_{i=0}^ra_ix_i) \equiv (\sum_{i=0}^ra_iy_i) \mod m \<br>\sum_{i=0}^ra_i(x_i-y_i) \equiv 0 \mod m \<br>a_0(x_0-y_0) + \sum_{i=1}^ra_i(x_i-y_i) \equiv 0 \mod m \<br>a_0(x_0-y_0) \equiv -\sum_{i=1}^ra_i(x_i-y_i) \mod m \<br>a_0 \equiv -\sum_{i=1}^ra_i(x_i-y_i) \cdot (x_0-y_0)^{-1}  \<br>$$<br>因此，可以得出结论，如果x与y发生碰撞，$x_0$由其它$x_i$决定，也就是说当其它$x_i$固定下来后，只有一个特定的$x_0$会发生碰撞。<br>因此$x_0$是固定的，所以随机数的组合减少了m倍，也就是$m^{r+1}/m$，|H|/m。</p>
<h3 id="数论定理"><a href="#数论定理" class="headerlink" title="数论定理"></a>数论定理</h3><p>令m为一个质数，$z \in Z_m$，$Z_m$是对m取余的整数集合也就是$[0,1,\dots ,m-1]$。对于$z!=0$，存在一个z的倒数$z^{-1}$，使得$z \cdot z^{-1}$的结果取余得1。<br>$$<br>z \cdot z^{-1} \equiv 1 \mod m<br>$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/05/14/%E7%AE%97%E6%B3%95/2017-05-14-%E6%95%A3%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/14/%E7%AE%97%E6%B3%95/2017-05-14-%E6%95%A3%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">散列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-14 11:17:00" itemprop="dateCreated datePublished" datetime="2017-05-14T11:17:00+00:00">2017-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背影"><a href="#背影" class="headerlink" title="背影"></a>背影</h2><p><strong>散列表是普通数组概念的推广</strong>。由于对普通数组可以直接寻址，使得能在O(1)时间内访问数组中的任意位置。</p>
<p>如果存储空间允许，我们可以提供一个数组，为每个关键字保留一个位置，以利用直接寻址的技术。</p>
<p><strong>当实际关键字数目比全部的可能关键字总数要小时，采用散列表就成为直接数组寻址的一种有效替代</strong>，因为散列表使用一个长度与实际存储的关键字数目成比例的数组来存储在散列表中，不是直接把关键字作为数组下标，而是根据关键字计算出相应的下标。</p>
<p>当实际关键字数目比全部的可能关键字总数要小时，可能会导致多个关键字映射到同一个下标。解决这种冲突有以下三种方式：</p>
<ol>
<li>链接方法</li>
<li>利用散列函数</li>
<li>开放寻址法</li>
</ol>
<p>当关键字集合是静态存储时（即关键字一但存入后不再改变）时，通过“完全散列”在最坏时间为O(1)的情况下完成关键字查找。</p>
<h2 id="直接寻址法"><a href="#直接寻址法" class="headerlink" title="直接寻址法"></a>直接寻址法</h2><h2 id="链接法"><a href="#链接法" class="headerlink" title="链接法"></a>链接法</h2><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><h2 id="完全散列"><a href="#完全散列" class="headerlink" title="完全散列"></a>完全散列</h2><hr>
<p><strong>参考</strong><br>《算法导论》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/05/13/%E7%AE%97%E6%B3%95/2016-11-25-PageRank%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/13/%E7%AE%97%E6%B3%95/2016-11-25-PageRank%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">PageRank算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-13 15:53:00" itemprop="dateCreated datePublished" datetime="2017-05-13T15:53:00+00:00">2017-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>总的来讲，对于一个特定的查询，搜索结果的排名取决于两组信息，关于网页的质量信息，和这个查询与每个网页的相关信息。PageRank算法就是一种衡量网页质量的方法。</p>
<h2 id="核心思想（原理）"><a href="#核心思想（原理）" class="headerlink" title="核心思想（原理）"></a>核心思想（原理）</h2><p>在互联网上，如果一个网页被很多其它网页所连接，说明它受到普遍的承认和信赖，那么它的排名就高。</p>
<h2 id="算法细节"><a href="#算法细节" class="headerlink" title="算法细节"></a>算法细节</h2><p>算法的思想如上文所诉，但实际上要复杂得多。比如说，对于来自不同网页的链接区别对待，因此网页排名高的那些网页的链接更可靠，于是给这些链接以较大的权重。</p>
<p>可以想像，一个新开的质量差的网站与另一个质量好的老网站它们的权重显然是不同的，否则就可以轻易作弊。</p>
<p>那接下来的问题就是这些网站的权重要如何度量呢，可以想到应该是网页本身的网页排名。现在麻烦来了，计算搜索结果的网页排名的过程中需要用到网页本身的排名。</p>
<p>解决方法是，把这个问题变成一个二维矩阵相乘的问题，并且用迭代的方法解决。先假定所有网页的排名是相同的，并且根据这个初始值，算出各个网页的第一次迭代排名，然后再根据第一次迭代排名算出第二次的排名 。</p>
<h2 id="PageRank计算方法"><a href="#PageRank计算方法" class="headerlink" title="PageRank计算方法"></a>PageRank计算方法</h2><p>假定如下向量，为第一、第二、…第N个网页的网页排名。<br>$$<br>B=(b_1,b_2,…b_N)^T<br>$$<br>如下矩阵为网页之间的链接数目，其中$a_{mn}$代表第m个网页指向第n个网页的链接数。<br>$$<br>A=<br>\begin{bmatrix}<br>a_{11} &amp; \cdots &amp; a_{1n} &amp; \cdots &amp; a_{1M} \<br>\cdots \<br>a_{m1} &amp; \cdots &amp; a_{mn} &amp; \cdots &amp; a_{mM} \<br>\cdots \<br>a_{M1} &amp; \cdots &amp; a_{Mn} &amp; \cdots &amp; a_{MM} \<br>\end{bmatrix}<br>$$<br>A是已知的，B是未知的，是我们需要计算的。<br>假定$B_i$是第i次的迭代的结果，那么<br>$$<br>B_i=A \cdot B_{i-1}<br>$$<br>初始假设：所有网页的排名都是1/N，即<br>$$<br>B_0=\left( \frac{1}{N},\frac{1}{N},\cdots,\frac{1}{N} \right)<br>$$</p>
<p><strong>注：</strong>关于矩阵计算的优化与技巧和链接数量的平滑，这里并没有给出，可以查阅相关资源。</p>
<hr>
<p><strong>参考</strong><br>《数学之美》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/05/09/%E5%85%B6%E5%AE%83/2017-05-09-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/09/%E5%85%B6%E5%AE%83/2017-05-09-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">静态博客搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-09 20:07:00" itemprop="dateCreated datePublished" datetime="2017-05-09T20:07:00+00:00">2017-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h2><p>能够获得反馈，然后你可以继续做出更复杂、更优秀的产品。</p>
<h2 id="如何写博客"><a href="#如何写博客" class="headerlink" title="如何写博客"></a>如何写博客</h2><p>下文会先介绍较流行的几种书写博客的方式，然后重点介绍通过静态网页生成器的方式如何来搭建博客。首先通过静态页面托管平台来简易搭建博客，并推荐一些实用的博客组件，最后简单介绍将博客搭建在服务器上的思路。</p>
<h2 id="书写博客的几种方式"><a href="#书写博客的几种方式" class="headerlink" title="书写博客的几种方式"></a>书写博客的几种方式</h2><p>目前比较地的方式主要有两种：</p>
<h3 id="在线博客平台"><a href="#在线博客平台" class="headerlink" title="在线博客平台"></a>在线博客平台</h3><p>例如：CSDN 博客中国 简书</p>
<h3 id="WordPress"><a href="#WordPress" class="headerlink" title="WordPress"></a>WordPress</h3><p><a target="_blank" rel="noopener" href="https://wordpress.org/themes/">wordpress样例</a></p>
<blockquote>
<p>WordPress是个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。</p>
</blockquote>
<p>在线博客平台的优点的简单，除了书写博客内容，不需要关心与网站有关的任何事情。缺点是有广告，死板，不geek。WordPress，则正好相反，操作麻烦，学习成本较高，对硬件资源有一定要求。优点是高度自由化。</p>
<h2 id="静态博客生成器介绍"><a href="#静态博客生成器介绍" class="headerlink" title="静态博客生成器介绍"></a>静态博客生成器介绍</h2><p>静态博客生成器使用Markdown（或其他渲染引擎）解析文章，可利用靓丽的主题生成静态网页。</p>
<p>Jekyll<br>hexo</p>
<p><a target="_blank" rel="noopener" href="https://hexo.io/themes/">hexo 样例 </a><br><a target="_blank" rel="noopener" href="http://jekyllthemes.org/">Jekyll 样例</a></p>
<hr>
<h2 id="通过静态页面托管平台（github-pages）极速搭建"><a href="#通过静态页面托管平台（github-pages）极速搭建" class="headerlink" title="通过静态页面托管平台（github pages）极速搭建"></a>通过静态页面托管平台（github pages）极速搭建</h2><p><strong>github pages介绍</strong></p>
<blockquote>
<p>Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在Github 上，你可以选择使用Github Pages 默认提供的域名github.io 或者自定义域名来发布站点。</p>
</blockquote>
<p><strong>搭建的过程分如下几个步骤</strong>：</p>
<ol>
<li><p> 搜索theme<br><a target="_blank" rel="noopener" href="https://github.com/search?utf8=%E2%9C%93&q=topic:jekyll-theme&type=">搜索</a></p>
</li>
<li><p>fork</p>
</li>
<li><p>设置github pages<br>Your site is published at <a target="_blank" rel="noopener" href="https://hwyoung.github.io/minimal-mistakes/">https://hwyoung.github.io/minimal-mistakes/</a></p>
</li>
<li><p>预览<br><a target="_blank" rel="noopener" href="https://hwyoung.github.io/minimal-mistakes/">https://hwyoung.github.io/minimal-mistakes/</a></p>
</li>
<li><p>写博客<br>minimal-mistakes/_posts/2016-07-20-helloworld.md<br>hello world!!!</p>
</li>
</ol>
<hr>
<h2 id="博客的书写—markdown"><a href="#博客的书写—markdown" class="headerlink" title="博客的书写—markdown"></a>博客的书写—markdown</h2><blockquote>
<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
</blockquote>
<p>在线markdown <a target="_blank" rel="noopener" href="https://www.zybuluo.com/mdeditor#748278">作业部落</a></p>
<hr>
<h2 id="实用的博客工具"><a href="#实用的博客工具" class="headerlink" title="实用的博客工具"></a>实用的博客工具</h2><h3 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h3><p>多说，disqus；</p>
<blockquote>
<p>Disqus是一家第三方社会化评论系统，主要为网站主提供评论托管服务</p>
</blockquote>
<h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>百度统计，google analytics；</p>
<blockquote>
<p>百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，有了这些信息，可以帮助用户改善访客在用户的网站上的使用体验，不断提升网站的投资回报率。</p>
</blockquote>
<h3 id="内容分享"><a href="#内容分享" class="headerlink" title="内容分享"></a>内容分享</h3><p>百度分享，AddThis</p>
<h3 id="数据公式—mathjax"><a href="#数据公式—mathjax" class="headerlink" title="数据公式—mathjax"></a>数据公式—mathjax</h3><p>mathjax使markdown能使用数据公式</p>
<h2 id="域名注册网站推荐。"><a href="#域名注册网站推荐。" class="headerlink" title="域名注册网站推荐。"></a>域名注册网站推荐。</h2><p>阿里云<br>GoDaddy</p>
<h2 id="自建服务器建站"><a href="#自建服务器建站" class="headerlink" title="自建服务器建站"></a>自建服务器建站</h2><p><strong>服务器提供商</strong><br>vps搬瓦工<br>内存：256MB<br>硬盘：10GB SSD<br>流量：500GB/月<br>价格：$19.99/年</p>
<p><strong>轻量级web容器</strong><br>Lighttpd<br>Lighttpd 是一个德国人领导的开源Web服务器软件，其根本的目的是提供一个专门针对高性能网站，安全、快速、兼容性好并且灵活的web server环境。具有非常低的内存开销、cpu占用率低、效能好以及丰富的模块等特点。</p>
<p><strong>网站云备份</strong><br>dropbox备份<br>Dropbox在Linux上可以如同在其他平台上使用。该服务在你的主目录下创建一个文件夹，可同步你放入到里面的所有数据。一个图标会出现在你的通知区，会显示数据何时同步。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/04/16/%E7%AE%97%E6%B3%95/2017-04-16-trie%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/16/%E7%AE%97%E6%B3%95/2017-04-16-trie%E6%A0%91/" class="post-title-link" itemprop="url">trie树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-16 10:59:00" itemprop="dateCreated datePublished" datetime="2017-04-16T10:59:00+00:00">2017-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/04/16/%E7%AE%97%E6%B3%95/2017-04-16-%E5%A4%9A%E6%A8%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-Aho%E2%80%93Corasick/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/avatar.png">
      <meta itemprop="name" content="hwyoung">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing Lite">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/16/%E7%AE%97%E6%B3%95/2017-04-16-%E5%A4%9A%E6%A8%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-Aho%E2%80%93Corasick/" class="post-title-link" itemprop="url">多模字符串匹配算法-Aho–Corasick</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-16 10:59:00" itemprop="dateCreated datePublished" datetime="2017-04-16T10:59:00+00:00">2017-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-02 06:52:04" itemprop="dateModified" datetime="2020-12-02T06:52:04+00:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在做实际工作中，最简单也最常用的一种自然语言处理方法就是关键词匹配，例如我们要对n条文本进行过滤，那本身是一个过滤词表的，通常进行过滤的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String document : documents) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String filterWord : filterWords) &#123;</span><br><span class="line">        <span class="keyword">if</span> (document.contains(filterWord)) &#123;</span><br><span class="line">            <span class="comment">//process ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果文本的数量是n，过滤词的数量是k，那么复杂度为O(nk)；如果关键词的数量较多，那么支行效率是非常低的。</p>
<blockquote>
<p>计算机科学中，Aho–Corasick算法是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法，用于在输入的一串字符串中匹配有限组“字典”中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。<strong>然而由于需要找到所有匹配数，如果每个子串互相匹配（如字典为a，aa，aaa，aaaa，输入的字符串为aaaa），算法的时间复杂度会近似于匹配的二次函数。</strong></p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在一般的情况下，针对一个文本进行关键词匹配，在匹配的过程中要与每个关键词一一进行计算。也就是说，每与一个关键词进行匹配，都要重新从文档的开始到结束进行扫描。AC自动机的思想是，在开始时先通过词表，对以下三种情况进行缓存：</p>
<ol>
<li>按照字符转移成功进行跳转（success表）</li>
<li>按照字符转移失败进行跳转（fail表）</li>
<li>匹配成功输出表（output表）</li>
</ol>
<p>因此在匹配的过程中，无需从新从文档的开始进行匹配，而是通过缓存直接进行跳转，从而实现近似于线性的时间复杂度。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>构建的过程分三个步骤，分别对success表，fail表，output表进行构建。其中output表在构建sucess和fail表进行都进行了补充。fail表是一对一的，output表是一对多的。</p>
<h3 id="按照字符转移成功进行跳转（success表）"><a href="#按照字符转移成功进行跳转（success表）" class="headerlink" title="按照字符转移成功进行跳转（success表）"></a>按照字符转移成功进行跳转（success表）</h3><p>sucess表实际就是一棵trie树，构建的方式和trie树是一样的，这里就不赘述。</p>
<h3 id="按照字符转移失败进行跳转（fail表）"><a href="#按照字符转移失败进行跳转（fail表）" class="headerlink" title="按照字符转移失败进行跳转（fail表）"></a>按照字符转移失败进行跳转（fail表）</h3><p>设这个节点上的字母为C，沿着他父亲的失败指针走，直到走到一个节点，他的儿子中也有字母为C的节点。然后把当前节点的失败指针指向那个字母也为C的儿子。如果一直走到了root都没找到，那就把失败指针指向root。 使用广度优先搜索BFS，层次遍历节点来处理，每一个节点的失败路径。</p>
<h3 id="匹配成功输出表（output表）"><a href="#匹配成功输出表（output表）" class="headerlink" title="匹配成功输出表（output表）"></a>匹配成功输出表（output表）</h3><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>举例说明，按顺序先后添加关键词he，she，,his，hers。在匹配ushers过程中。先构建三个表，如下图，实线是sucess表，虚线是fail表，结点后的单词是ourput表。</p>
<p><img src="./_image/ac.png"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>gist 2fed6f4569d4da8029e7ef08458cad6b</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hwyoung"
      src="/avatar.png">
  <p class="site-author-name" itemprop="name">hwyoung</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hwyoung</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
