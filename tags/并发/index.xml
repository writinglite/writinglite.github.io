<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发 on Writing Lite</title><link>/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on Writing Lite</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><atom:link href="/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Java并发测试CyclicBarrier与CountDownLatch</title><link>/post/java/2019-08-08-java%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95cyclicbarrier%E4%B8%8Ecountdownlatch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/post/java/2019-08-08-java%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95cyclicbarrier%E4%B8%8Ecountdownlatch/</guid><description>CountDownLatch 相关的api
//构造方法 public CountDownLatch(int count) //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 public void await() throws InterruptedException { }; //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行 public boolean await(long timeout, TimeUnit unit) throws InterruptedException { }; //将count值减1 public void countDown() { }; 简单来说它的执行逻辑是：先初始化count，当执行countDown()时count会减1，当count为零时之前因为await()被挂起的线程都会被唤醒。
示例代码：
public static void main(String[] args) { int bash = 10; CountDownLatch countDownLatch = new CountDownLatch(1); for (int index = 0; index &amp;lt; bash; index++) { new Thread(new Runnable() { @Override public void run() { try { countDownLatch.await(); } catch (InterruptedException e) { e.</description></item></channel></rss>