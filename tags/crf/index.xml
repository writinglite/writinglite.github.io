<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>crf on Writing Lite</title><link>/tags/crf.html</link><description>Recent content in crf on Writing Lite</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 16 Oct 2020 21:07:00 +0000</lastBuildDate><atom:link href="/tags/crf/index.xml" rel="self" type="application/rss+xml"/><item><title>DeepLearning中CRF的Tensorflow代码实现</title><link>/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2020-10-16-deeplearning%E4%B8%ADcrf%E7%9A%84tensorflow%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html</link><pubDate>Fri, 16 Oct 2020 21:07:00 +0000</pubDate><guid>/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2020-10-16-deeplearning%E4%B8%ADcrf%E7%9A%84tensorflow%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.html</guid><description>主方法 def crf_log_likelihood( inputs: TensorLike, tag_indices: TensorLike, sequence_lengths: TensorLike, transition_params: Optional[TensorLike] = None, ) -&amp;gt; tf.Tensor: &amp;#34;&amp;#34;&amp;#34;Computes the log-likelihood of tag sequences in a CRF. Args: inputs: A [batch_size, max_seq_len, num_tags] tensor of unary potentials to use as input to the CRF layer. tag_indices: A [batch_size, max_seq_len] matrix of tag indices for which we compute the log-likelihood. sequence_lengths: A [batch_size] vector of true sequence lengths. transition_params: A [num_tags, num_tags] transition matrix, if available.</description></item><item><title>DeepLearning中CRF计算原理</title><link>/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2020-10-16-deeplearning%E4%B8%ADcrf%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86.html</link><pubDate>Fri, 16 Oct 2020 21:07:00 +0000</pubDate><guid>/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2020-10-16-deeplearning%E4%B8%ADcrf%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86.html</guid><description>主要内容来处：https://createmomo.github.io：
CRF Layer on the Top of BiLSTM - 1 Outline and Introduction CRF Layer on the Top of BiLSTM - 2 CRF Layer (Emission and Transition Score) CRF Layer on the Top of BiLSTM - 3 CRF Loss Function CRF Layer on the Top of BiLSTM - 4 Real Path Score CRF Layer on the Top of BiLSTM - 5 The Total Score of All the Paths CRF Layer on the Top of BiLSTM - 6 Infer the Labels for a New Sentence CRF Layer on the Top of BiLSTM - 7 Chainer Implementation Warm Up CRF Layer on the Top of BiLSTM - 8 Demo Code 通常在序列标注模型的最后一层layer会添加CRF计算，因为序列标注任务中lable之前有较强的约束性，例如，B-Person与I-Person之前有强关联，B-Person和I-Locations之间有强“非关联”，而CRF模型中的转移矩阵则可以很好体现这些特性。</description></item><item><title>pytorch BI-LSTM CRF 代码解读</title><link>/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2019-09-24-pytorch-bi-lstm-crf%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB.html</link><pubDate>Tue, 24 Sep 2019 10:07:00 +0000</pubDate><guid>/post/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2019-09-24-pytorch-bi-lstm-crf%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB.html</guid><description>词性标注是比较基本的NLP任务，通常我们可以使用BI-LSTM CRF模型来完成；CRF在这里起的作用是能够约束标签序列使结果的合法性更好。例如，如果不使用CRF可能的结果是B-LOC O E-LOC
BLSTM这里就没什么说的了，我们这篇文章主要通过pytorch官网给的代码，讲解下CRF的实现部分。
我们定义两种概率矩阵，发射概率（emission ）和转移概率（transition）。$\text{EMIT}(y_i \rightarrow x_i)$表示 $x_i$映射到$y_i$的非归一化概率，$\text{TRANS}(y_{i-1} \rightarrow y_i)$表示 $y_{i-1}$转移到$y_{i}$的概率。 $$ P(y|x) = \frac{\exp{(\text{Score}(x, y)})}{\sum_{y'} \exp{(\text{Score}(x, y')})} \
\text{Score}(x,y) = \sum_i \log \psi_i(x,y) \
\text{Score}(x,y) = \sum_i \log \psi_\text{EMIT}(y_i \rightarrow x_i) + \log \psi_\text{TRANS}(y_{i-1} \rightarrow y_i) $$
因而在训练中，我们只需要最大化似然概率$P(y|x)$即可，这里我们利用对数似然 $$ \log{P(y|x)} = \log{(\frac{\exp{(\text{Score}(x, y)})}{\sum_{y'} \exp{(\text{Score}(x, y')})})} \
= \text{Score}(x, y) - \log{(\sum_{y'} \exp{(\text{Score}(x, y')}))} $$ 所以我们将损失函数定义为$-\log{P(y|x)}$，就可以利用梯度下降法来进行网络的学习了。
在对损失函数进行计算的时候，$\text{Score}(x,y)$的计算很简单，而$\log{(\sum_{y'} \exp{(\text{Score}(x, y')}))}$（下面记作logsumexp）的计算稍微复杂一些，这里使用前向算法（forward algorithm）来进行计算。
如下代码中，feats 代表[W1, W2, W3]，next_tags代表[t1, t2, t3, t4]，当feat=W1，next_tag=t1时，feat里的值是[0.1, 0.2, 0.</description></item></channel></rss>