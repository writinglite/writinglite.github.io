<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>guice on Writing Lite</title><link>/tags/guice/</link><description>Recent content in guice on Writing Lite</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 18 Apr 2019 13:03:00 +0000</lastBuildDate><atom:link href="/tags/guice/index.xml" rel="self" type="application/rss+xml"/><item><title>Java NIO</title><link>/post/java/2019-04-18-java-nio/</link><pubDate>Thu, 18 Apr 2019 13:03:00 +0000</pubDate><guid>/post/java/2019-04-18-java-nio/</guid><description>IO (input/output) 通常指数据在内部存储器和外部存储器或其他周边设备之间的输入和输出。 NIO 是 Non-blocking IO 的缩写，即非阻塞式 IO，是一种计算机处理输入和输出的一种方式。
原始 IO 处理方式是，当数据可读之前会一直等待并占用线程资源却不做任何事情，因此当需要处理多个 chanle时就需要启用多个线程；而 NIO 可以只用一个线程来处理多个 chanle ,因为 NIO当数据可读之前不会一直傻等，而是每隔一段时间就检查，那么对于多个 chanle 来说，他们中有一个是可读状态才使用 cpu执行；
JJava IO: A classic IO server design - one connection handled by one thread.
Java NIO: A single thread managing multiple connections
&amp;ndash; 参考：
https://tech.meituan.com/2016/11/04/nio.html
https://segmentfault.com/a/1190000017040893
http://tutorials.jenkov.com/java-nio/nio-vs-io.html</description></item><item><title>Guice注入SLF4J</title><link>/post/java/2017-04-06-guice%E6%B3%A8%E5%85%A5slf4j/</link><pubDate>Thu, 06 Apr 2017 21:57:00 +0000</pubDate><guid>/post/java/2017-04-06-guice%E6%B3%A8%E5%85%A5slf4j/</guid><description>创建注解 import javax.inject.Scope; import java.lang.annotation.Documented; import java.lang.annotation.Retention; import java.lang.annotation.Target; import static java.lang.annotation.ElementType.FIELD; import static java.lang.annotation.RetentionPolicy.RUNTIME; @Scope @Documented @Retention(RUNTIME) @Target(FIELD) public @interface Log { } 自定义MembersInjector import com.google.inject.MembersInjector; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.lang.reflect.Field; public class SLF4JMembersInjector&amp;lt;T&amp;gt; implements MembersInjector&amp;lt;T&amp;gt; { private final Field field; private final Logger logger; public SLF4JMembersInjector(Field field) { this.field = field; this.logger = LoggerFactory.getLogger(field.getDeclaringClass()); field.setAccessible(true); } public void injectMembers(T t) { try { field.set(t, logger); } catch (IllegalAccessException e) { throw new RuntimeException(e); } } } 创建TypeListener import project.</description></item><item><title>Guice 使用方法</title><link>/post/java/2017-05-13-guice%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</link><pubDate>Thu, 16 Mar 2017 09:03:00 +0000</pubDate><guid>/post/java/2017-05-13-guice%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</guid><description>注入方式 构造方法注入 通过构造方法注入，相对其它方法的好处是，与guice的耦合较低，即使之后不使用guice框架也不用大范围的修改代码。
public class MyImplement { private MyProperty myProperty; @Inject public MyImplement(MyProperty myProperty) { this.myProperty =myProperty; } } 属性注入 属性注入最方便，但不那么符合规范。
public class MyImplement { @Inject private MyProperty myProperty; } 方法注入 如果之前用的是spring通过set方法进行的配置，那么转换到guice就相对简单。
public class MyImplement { private MyProperty myProperty; @Inject public void setMyProperty(MyProperty myProperty) { this.myProperty =myProperty; } } provider注入 如果一个对象有两种或多种不同的生成方式，则可以使用provider方式进行注入。
public static class MyProvider1 implements Provider&amp;lt;MyInterface&amp;gt; { @Inject @Named(&amp;#34;myproperty1&amp;#34;) private MyProperty myProperty; public MyInterface invoke(MyInterface request) { MyImplement myImplement = new MyImplement(); myImplement.</description></item></channel></rss>